#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderArmLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  encoderArmRight, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  touchTop,       sensorTouch)
#pragma config(Sensor, dgtl10, touchBottom,    sensorTouch)
#pragma config(Sensor, dgtl11, jumper,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intakeL,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           FR,            tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           armLL,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           BL,            tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port5,           BR,            tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           armLU,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           armRU,         tmotorVex393, openLoop)
#pragma config(Motor,  port8,           FL,            tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port9,           armRL,         tmotorVex393, openLoop)
#pragma config(Motor,  port10,          intakeR,       tmotorVex393, openLoop)
//!!!!!!!! status port on power expander goes analog8(in8) on the cortex!!!!!!!!!!//
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "MiscFunctions.c"
#include "ChassisFunctions.c"

/*Runs the mechanum drive using the following motors
FR = front right
FL = front left
BL = Back left
BR = back right

bottomThresh = a value beneath which a channel will not have any input
topThresh = a value beneath which a channel will input a fraction of its value
lowGear = a value by which a channel will be divided when below topThresh
cutOff = a motor power beneath which no power will be sent to the motor
*/

//tells the function if it should run the set up things
bool firstTime = true;

//value coming from the controller to control rotational
int turnVal;
int rpm;
int goalAdd;

//error variables for use later
float driveError;
float driveOldError;
int driveChange;

//set constants for PID
float driveKp;
float driveKi;
float driveKd;

//prepares goal for use with gyro
int goal;

//holds gyro value for future use
int gyroValue;
//frameRate = time in Miliseconds that each loop takes
//roateSlope = the slope of the line of rotations per minute over motor power
void MechanumPID(int bottomThresh, int topThresh, int lowGear, int cutOff, int frameRate, float rotateSlope)
{
	//if it's the first time run setup
	if(firstTime)
	{
		if(frameRate == 0)
		{
			frameRate = 1;
		}
		if(lowGear == 0)
		{
			lowGear = 1;
		}
		//error variables for use later
		driveOldError = 0;
		driveChange = 0;

		//resets variables for use later
		proportion = 0;
		integral = 0;
		derivative = 0;

		//set constants for PID
		driveKp = .14;
		driveKi = 0;
		driveKd = 0;

		//prepares goal for use with gyro
		goal = SensorValue[gyro];

		firstTime = false;
	}

	//getting the rotational movement control
	turnVal = vexRT[Ch1];
	if(abs(turnVal)< bottomThresh)
  {
    turnVal = 0;
  }
  else if(abs(turnVal) < topThresh)
  {
    turnVal = turnVal/lowGear;
  }
	rpm = turnVal * rotateSlope;
	goalAdd = floor((rpm*360)/(60 * (1000/frameRate)));
	goal += goalAdd
	if(turnVal == 0)
	{
		goal = SensorValue[gyro];
	}

	//preparing error...mostly magic
	gyroValue = SensorValue[gyro];
	gyroValue = centerGyro(goal, gyroValue);
	driveError = adjustGyro(gyroValue);

	driveChange = PID(driveKp, driveKi, driveKd, driveError, driveOldError);

	//these variables allow you to change which channels conrtol different movements
  XVal = vexRT[Ch4];	//left/right
  ZVal = vexRT[Ch3];	//forward/back
  RotateVal = driveChange;	//rotational for pid

  //these manipulate the channel values going into the main function
  //*see top and bottom thresh above
  if(abs(ZVal)< bottomThresh)
  {
    ZVal = 0;
  }
  else if(abs(ZVal) < topThresh)
  {
    ZVal = ZVal/lowGear;
  }

  if(abs(XVal)< bottomThresh)
  {
    XVal = 0;
  }
  else if(abs(XVal) < topThresh)
  {
    XVal = XVal/lowGear;
  }

	weightMechanum(XVal, ZVal, RotateVal);

  //Set powers to motors
	setFR(FRPower, cutOff);
	setFL(FLPower, cutOff);
	setBL(BLPower, cutOff);
	setBR(BRPower, cutOff);

	driveOldError = driveError;
}
//bottomThresh = a value beneath which a channel will not have any input
int bottomThresh = 0;
//topThresh = a value beneath which a channel will input a fraction of its value
int topThresh = 0;
//lowGear = a value by which a channel will be divided when below topThresh
int lowGear = 0;

//////////////////////////arm/////////////////////////////////
//trough = the height of the trough as specified by the encoders
int trough = 75;
//highGoal = the height of the trough as specified by the encoders
int highGoal = 0;
//armSpeed = the base value for the arm
int armSpeed = 127;

//////////////////////////intake//////////////////////////////
//inSpeed = speed of intaking
int inSpeed = 127;
//outSpeed = speed of depositing
int outSpeed = 127;

task main()
{
	while(true)
	{
		//runs the joystick control of the chassis
		MechanumPID(0, 0, 1, 30, 100, .25);



//universal framerate for PID
			wait1Msec(100);
	}



}
