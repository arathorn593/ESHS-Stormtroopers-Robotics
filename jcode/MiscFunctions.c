#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderArmLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  encoderArmRight, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  touchTop,       sensorTouch)
#pragma config(Sensor, dgtl10, touchBottom,    sensorTouch)
#pragma config(Sensor, dgtl11, jumper,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intakeL,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           FR,            tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           armLL,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           BL,            tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port5,           BR,            tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           armLU,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           armRU,         tmotorVex393, openLoop)
#pragma config(Motor,  port8,           FL,            tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port9,           armRL,         tmotorVex393, openLoop)
#pragma config(Motor,  port10,          intakeR,       tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!!!!!!!! status port on power expander goes analog2(in8) on the cortex!!!!!!!!!!//
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int controllerState = 0;
//1 = minion in control
//0 = master in control

//boolean for battery
bool batteryView = false;

//variables that hold the main values for each part of PID
float proportion;
float integral;
float derivative;

//variables for the mechanum weighting
//these store the value that controlls how much each direction is "wieghted"
//in the final setup
float XWeight;
float ZWeight;
float RotateWeight;
//these hold the value of each wheel's power so it can be manipulated
int FRPower;
int FLPower;
int BLPower;
int BRPower;

/////////////////////////general misc functions/////////////////////////////////////////////////////////////////////////////////////////////
//weights the desired movement in order to get the right moves
//X, Z, & rotate val are all floats from -127 to 127
void weightMechanum(float XVal, float ZVal, float RotateVal)
{
	//just to prevent devide by zero explosion
	if(abs(RotateVal) + abs(ZVal) + abs(XVal) == 0)
	{
		return;
	}
	//this weights each direction by finding what percentage of
  //the total movement they make up
  XWeight = abs(XVal)/(abs(RotateVal) + abs(ZVal) + abs(XVal));
  ZWeight = abs(ZVal)/(abs(RotateVal) + abs(ZVal) + abs(XVal));
  RotateWeight = abs(RotateVal)/(abs(RotateVal) + abs(ZVal) + abs(XVal));

  //these calculate the power on each motor by adding each scenario(Z, X, rotate)
  //each scenario is found by multiplying the channel value by the channel weight
  // by a -1 if those motors are reversed in that scenario.
  FRPower = ceil(XVal*XWeight + ZVal*ZWeight + -1 * RotateVal * RotateWeight);
  FLPower = ceil(-1*XVal*XWeight + ZVal*ZWeight + RotateVal * RotateWeight);
  BLPower = ceil(XVal*XWeight + ZVal*ZWeight + RotateVal * RotateWeight);
  BRPower = ceil(-1*XVal*XWeight + ZVal*ZWeight + -1 * RotateVal * RotateWeight);
}

void resetEncoders()
{
	nMotorEncoder[BL] = 0;
	nMotorEncoder[BR] = 0;

}

void resetGyro()
{
	SensorType[in1] = sensorNone;
	wait1Msec(1000);

	SensorType[in1] = sensorGyro;
	wait1Msec(1500);
}

//adjusts the gyro and goal by the same margin so the goal can be 0
//so that the robot always turns the direction of least distance
//remember to set gyro to zero after this function
int centerGyro(int goal, int gyroValue)
{
	int blah = goal * gyroValue;
	if((blah)>0)
	{
		gyroValue = goal - gyroValue;
	}
	else if(blah < 0)
	{
		gyroValue = gyroValue - goal;
	}


	return gyroValue;
}

//takes the raw gyro value and adjusts it to work with PID
//counter clock wise goes 0 to -1799 then 1800 to 0, clock wise is reverse of that
int adjustGyro(int gyroValue)
{
	//if it is from -1800 to -3599 then convert it to positive
	if(gyroValue <= -1800)
	{
		gyroValue += 3600;
		return gyroValue;
	}
	//if it is from 1801 to 3599 then convert it to negative
	else if(gyroValue >= 1800)
	{
		gyroValue -= 3600;
		return gyroValue;
	}
	else
	{
		return gyroValue;
	}
}

//inputs the constants and error and returns the change
int PID(float Kp, float Ki, float Kd, float error, float oldError)
{
	proportion = Kp * error;

	integral +=error * Ki;
	if(error == 0)
	{
		integral = 0;
	}

	derivative = (error - oldError) * Kd;

	return proportion + integral + derivative;
}

task battery()
{
	bLCDBacklight = true;                                    // Turn on LCD Backlight
	string mainBattery, backupBattery;
	int battery2Level;

while((nLCDButtons == 2)||(nLCDButtons == 3)||(nLCDButtons == 6)||(nLCDButtons == 7))                                                        // An infinite loop to keep the program running until you terminate it
{
clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

//Display the Primary Robot battery voltage
displayLCDString(0, 0, "Primary: ");
sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
displayNextLCDString(mainBattery);

//gets the expander's battery voltage
battery2Level = (int)((float)SensorValue[in8] * 5.48);

//Display the Backup battery voltage
displayLCDString(1, 0, "Expander: ");
sprintf(backupBattery, "%1.2f%c", battery2Level, 'V');    //Build the value to be displayed
displayNextLCDString(backupBattery);

	}
	batteryView = false;
}

void setIntakeL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[intakeL] = 0;
	}
	else
	{
		motor[intakeL] = magnitude;
	}
}

void setIntakeR(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[intakeR] = 0;
	}
	else
	{
		motor[intakeR] = magnitude;
	}
}


void startIntake(int magnitude, int cutOff)
{
	setIntakeL(magnitude, cutOff);
	setIntakeR(magnitude, cutOff);
}

void stopIntake()
{
	motor[intakeL] = 0;
	motor[intakeR] = 0;
}

//////////////////////////////////////////8-Bar/////////////////////////////////////////////////////////////////////////////

void resetArmEncoders()
{
	SensorValue[encoderArmLeft] = 0;
	SensorValue[encoderArmRight] = 0;
}
//these set individual motors so the cutoff is not needed in the main code
void setArmLL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[armLL] = 0;
	}
	else
	{
		motor[armLL] = magnitude;
	}
}

void setArmLU(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[armLU] = 0;
	}
	else
	{
		motor[armLU] = magnitude;
	}
}

void setArmRL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[armRL] = 0;
	}
	else
	{
		motor[armRL] = magnitude;
	}
}

void setArmRU(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[armRU] = 0;
	}
	else
	{
		motor[armRU] = magnitude;
	}
}

void setArmLeft(int magnitude, int cutOff)
{
	setArmLL(magnitude, cutOff);
	setArmLU(magnitude, cutOff);
}

void setArmRight(int magnitude, int cutOff)
{
	setArmRL(magnitude, cutOff);
	setArmRU(magnitude, cutOff);
}

void setArm(int magnitude, int cutOff)
{
	setArmLL(magnitude, cutOff);
	setArmLU(magnitude, cutOff);
	setArmRL(magnitude, cutOff);
	setArmRU(magnitude, cutOff);
}

void stopArm()
{
	motor[armLL] = 0;
	motor[armLU] = 0;
	motor[armRL] = 0;
	motor[armRU] = 0;
}

void setFR(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[FR] = 0;
	}
	else
	{
		motor[FR] = magnitude;
	}
}

void setFL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[FL] = 0;
	}
	else
	{
		motor[FL] = magnitude;
	}
}

void setBL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[BL] = 0;
	}
	else
	{
		motor[BL] = magnitude;
	}
}

void setBR(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[BR] = 0;
	}
	else
	{
		motor[BR] = magnitude;
	}
}

//simplify coding when all motors on one side work together.
void setRightDrive(int magnitude, int cutOff)
{
	setFR(magnitude, cutOff);
	setBR(magnitude, cutOff);
}

void setLeftDrive(int magnitude, int cutOff)
{
	setFL(magnitude, cutOff);
	setBL(magnitude, cutOff);
}

//don't tell me I need to comment this
void stopDrive()
{
  motor[FR]=0;
  motor[FL]=0;
  motor[BL]=0;
  motor[BR]=0;
}

void setIntakeL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[intakeL] = 0;
	}
	else
	{
		motor[intakeL] = magnitude;
	}
}

void setIntakeR(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[intakeR] = 0;
	}
	else
	{
		motor[intakeR] = magnitude;
	}
}
//michael le is the coolest dude ive ever met in my entire life!!!!!!!!!!!!!!//
//this is so much fun//
//im having a great time//
//dude guess what!//
//michael le knows my name!//
//just typin' like a boss//
//     //    //  // // ////
//////////////////////////////////////////////////////////////////////////////////
//-__-//
////////////////////hi michael//
//this is getting pretty boring//
//i think ill stop//























//nahh//
