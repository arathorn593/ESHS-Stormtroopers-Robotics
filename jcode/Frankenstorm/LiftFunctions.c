#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderRight,   sensorQuadEncoder)
#pragma config(Motor,  port2,           FR,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           BL,            tmotorVex393, openLoop)
#pragma config(Motor,  port5,           BR,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           FL,            tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "MiscFunctions.c"
/////////////////////////////////////////Autonomous//////////////////////////////////////////////////

//////////////////////////////////////////////Chain Lift/////////////////////////////////////////////////

void setLiftU(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[liftU] = 0;
	}
	else
	{
		motor[liftU] = magnitude;
	}
}

void setLiftL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[liftL] = 0;
	}
	else
	{
		motor[liftL] = magnitude;
	}
}

void setLift(int magnitude, int cutOff)
{
	setLiftU(magnitude, cutOff);
	setLiftL(magnitude, cutOff);
}

void setDumpR(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[dumpR] = 0;
	}
	else
	{
		motor[dumpR] = magnitude;
	}
}

void setDumpL(int magnitude, int cutOff)
{
	if(abs(magnitude) < cutOff)
	{
		motor[dumpL] = 0;
	}
	else
	{
		motor[dumpL] = magnitude;
	}
}

void setDump(int magnitude, int cutOff)
{
	setDumpR(magnitude, cutOff);
	setDumpL(magnitude, cutOff);
}

void stopDump()
{
	motor[dumpL] = 0;
	motor[dumpR] = 0;
}

//see misc functions for intake autonomous

/////////////////////////////////////////Driver//////////////////////////////////////////////////////

void dump(int magnitude, int cutOff)
{
	if(vexRT[Btn6D] == 1)
	{
		setDump(inMagnitude, cutOff);
	}
	else if(vexRT[Btn6U] == 1)
	{
		setDump(-1*outMagnitude, cutOff);
	}
	else
	{
		stopDump8i9();
	}
}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Nathan's having fun:P
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//moo says the cow and the cow says quack
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//party at joseph's house on janurary 16th 4pm-3am
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//just kidding its actually until 6pm on janurary 18th
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//just so that you don't miss your weekend, it resumes on janurary 21st and goes through the rest of the week.
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//why do you throw things so much?
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//uuuuummmmmmmmmmmmmmm idunno.
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//michael Le you excist!
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////

//runs intake control, in and out magnitude are both positive
void intake(int inMagnitude, int outMagnitude, int cutOff)
{
	if(vexRT[Btn6D] == 1)
	{
		startIntake(inMagnitude, cutOff);
	}
	else if(vexRT[Btn6U] == 1)
	{
		startIntake(-1*outMagnitude, cutOff);
	}
	else
	{
		stopIntake();
	}
}

void liftControl(int trough, int highGoal, int magnitude, int cutOff)
{
	//these prevent the arm from moving outside its range of motion
	if(SensorValue[touchTop] == 1)
	{
		stopArm();
	}
	else if(SensorValue[touchBottom] == 1)
	{
		stopArm();
	}

	//resets encoders to promote accuracy
	if(SensorValue[touchBottom] == 1)
	{
		SensorValue[encoderArmLeft] = 0;
		SensorValue[encoderArmRight] = 0;
	}

	//variable that keeps track of the motor power for use in the pid
	int motorPower = 0;

	//these put the value of the top and bottom buttons in the apropriate variable
	baseNewVal = vexRT[Btn8D];
	topNewVal = vexRT[btn8U];
	//this allows either of the middle buttons to trigger the middle varible
	if((vexRT[Btn8L] == 1) || (vexRT[Btn8L] == 1))
	{
		midNewVal = 1;
	}
	else
	{
		midNewVal = 0;
	}

	//These 3 if statements say that for each of the hieghts
	//if the new value is 1(pressed) and the old value is 0(unpressed)
	//then it was a legitamate button press and sets the state to the
	//correct level.
	if((baseNewVal == 1) && (baseOldVal == 0))
	{
		state = 1;
	}

	if((midNewVal == 1) && (midOldVal == 0))
	{
		state = 2;
	}

	if((topNewVal == 1) && (topOldVal == 0))
	{
		state = 3;
	}

	topOldVal = topNewVal;
	midOldVal = midNewVal;
	baseOldVal = baseNewVal;

	if(vexRT[Btn6D] == 1)
	{
		if(SensorValue[touchBottom] == 0)
		{
			motorPower = -127;
		}
		else
		{
			motorPower = 0;
		}
	}
	else if(vexRT[Btn6U] == 1)
	{
		if(SensorValue[touchTop] == 0)
		{
			motorPower = 127;
		}
		else
		{
			motorPower = 0;
		}
	}
	else
	{
		if(state == 1)
		{
			if(SensorValue[touchBottom] == 0)
			{
				motorPower = -127;
			}
			else
			{
				motorPower = 0;
				state = 0;
			}
		}
		else if(state == 2)
		{
			if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > trough)
			{
				motorPower = -127;
			}
			else if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > trough)
			{
				motorPower = 127;
			}
			else
			{
				motorPower = 0;
				state = 0;
			}
		}
		else if(state == 3)
		{
			if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > highGoal)
			{
				motorPower = -127;
			}
			else if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > highGoal)
			{
				motorPower = 127;
			}
			else
			{
				motorPower = 0;
				state = 0;
			}
		}
		else
		{
			motorPower = 0;
		}
	}
}

void dumpControl(int dump, int ground, int magnitude, int cutOff)
{
	//these prevent the arm from moving outside its range of motion
	if(SensorValue[touchTop] == 1)
	{
		stopArm();
	}
	else if(SensorValue[touchBottom] == 1)
	{
		stopArm();
	}

	//resets encoders to promote accuracy
	if(SensorValue[touchBottom] == 1)
	{
		SensorValue[encoderArmLeft] = 0;
		SensorValue[encoderArmRight] = 0;
	}

	//variable that keeps track of the motor power for use in the pid
	int motorPower = 0;

	//these put the value of the top and bottom buttons in the apropriate variable
	baseNewVal = vexRT[Btn8D];
	topNewVal = vexRT[btn8U];
	//this allows either of the middle buttons to trigger the middle varible
	if((vexRT[Btn8L] == 1) || (vexRT[Btn8L] == 1))
	{
		midNewVal = 1;
	}
	else
	{
		midNewVal = 0;
	}

	//These 3 if statements say that for each of the hieghts
	//if the new value is 1(pressed) and the old value is 0(unpressed)
	//then it was a legitamate button press and sets the state to the
	//correct level.
	if((baseNewVal == 1) && (baseOldVal == 0))
	{
		state = 1;
	}

	if((midNewVal == 1) && (midOldVal == 0))
	{
		state = 2;
	}

	if((topNewVal == 1) && (topOldVal == 0))
	{
		state = 3;
	}

	topOldVal = topNewVal;
	midOldVal = midNewVal;
	baseOldVal = baseNewVal;

	if(vexRT[Btn6D] == 1)
	{
		if(SensorValue[touchBottom] == 0)
		{
			motorPower = -127;
		}
		else
		{
			motorPower = 0;
		}
	}
	else if(vexRT[Btn6U] == 1)
	{
		if(SensorValue[touchTop] == 0)
		{
			motorPower = 127;
		}
		else
		{
			motorPower = 0;
		}
	}
	else
	{
		if(state == 1)
		{
			if(SensorValue[touchBottom] == 0)
			{
				motorPower = -127;
			}
			else
			{
				motorPower = 0;
				state = 0;
			}
		}
		else if(state == 2)
		{
			if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > trough)
			{
				motorPower = -127;
			}
			else if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > trough)
			{
				motorPower = 127;
			}
			else
			{
				motorPower = 0;
				state = 0;
			}
		}
		else if(state == 3)
		{
			if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > highGoal)
			{
				motorPower = -127;
			}
			else if((SensorValue[encoderArmLeft] + SensorValue[encoderArmRight])/2 > highGoal)
			{
				motorPower = 127;
			}
			else
			{
				motorPower = 0;
				state = 0;
			}
		}
		else
		{
			motorPower = 0;
		}
	}
}
