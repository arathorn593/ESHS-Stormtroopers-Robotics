#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Motor,  port2,           RB,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           LF,            tmotorVex393, openLoop)
#pragma config(Motor,  port4,           LB,            tmotorVex393, openLoop)
#pragma config(Motor,  port5,           RF,            tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"
void pre_auton()
{
  bStopTasksBetweenModes = true;
}
int directionMode=1;
void stopC()
{
  motor[RF]=0;
  motor[RB]=0;
  motor[LF]=0;
  motor[LB]=0;
}
void forward(int magnitude,int r){
  if (r==0){
    motor[RF]=magnitude;
    motor[RB]=magnitude;
    motor[LF]=magnitude;
    motor[LB]=magnitude;
  }
  if (r==1){//this checks if ch4 is being manipulated, combines the forward and turn functions
    if (vexRT[Ch4]<0){
    motor[RF]=magnitude;
    motor[RB]=magnitude;
    motor[LF]=0;
    motor[LB]=0;
  }
    if (vexRT[Ch4]>0){
    motor[LF]=magnitude;
    motor[LB]=magnitude;
    motor[RF]=0;
    motor[RB]=0;
  }
  }
  if (r==2){//used when manipulating gyroscope, see "void forwardZero"
    if (SensorValue[Gyro]<=0){
    motor[RF]=magnitude;
    motor[RB]=magnitude;
    motor[LF]=60;
    motor[LB]=60;
  }
    if (SensorValue[Gyro]>0){
    motor[LF]=magnitude;
    motor[LB]=magnitude;
    motor[RF]=60;
    motor[RB]=60;
  }
  }
  if (r==3){//unused, calibration variable
    int L=0;
    int R=68;
    motor[LF]=127-L;
    motor[LB]=127-L;
    motor[RF]=127-R;
    motor[RB]=127-R;
  }
}
void right(int magnitude,int r){//used to slide left and right
  motor[RF]=magnitude;
  motor[RB]=-magnitude;
  motor[LF]=-magnitude;
  motor[LB]=magnitude;
  if (r==10){//unused
    if (vexRT[Ch4]<0){
    motor[RF]=magnitude;
    motor[LF]=magnitude;
    motor[LB]=magnitude/2;
    motor[RB]=magnitude/2;
  }
    if (vexRT[Ch4]>0){
    motor[LB]=magnitude;
    motor[RB]=magnitude;
    motor[LF]=magnitude/2;
    motor[RF]=magnitude/2;
  }
}
}
void turn(int magnitude){//point turn, not used when going forward
  if (vexRT[Btn6U]==0){
  motor[RF]=-magnitude;
  motor[RB]=-magnitude;
  motor[LF]=magnitude;
  motor[LB]=magnitude;
}
  else{//alternative point turn mode
    if (magnitude>50){
      motor[LF]=magnitude;
      motor[RB]=-magnitude;
   }
    if (magnitude<50){
      motor[RF]=-magnitude;
      motor[LB]=magnitude;
    }
  }
}
void diagonal(int magnitude,int direction){
  if (direction==2){
    motor[RF]=magnitude;
    motor[LB]=magnitude;
  }
  if (direction==1){
    motor[LF]=magnitude;
    motor[RB]=magnitude;
  }
}
void AT(int degree, int magnitude){//autonomous turn, most precise
  SensorValue[Gyro]=0;
  degree=degree*10;
  if (SensorValue[Gyro]>degree+400){
  while (SensorValue[Gyro]>degree+400){
    turn(magnitude);
  }
}
  if (SensorValue[Gyro]<degree-400){
  while (SensorValue[Gyro]<degree-400){
    turn(-magnitude);
  }
}
  stopC();
  SensorValue[Gyro]=0;
}
void AF(int t,int magnitude){//autonomous go forward using gyroscope
  SensorValue[Gyro]=0;
  int counter=0;
  while (counter<t){
    forward(magnitude,2);
    wait1Msec(1);
    counter=counter+1;
  }
  stopC();
}
void forwardZero(){
  forward(127,2);
}
task autonomous(){
  SensorValue[Gyro]=0;
  AF(1000,127);
  AT(90,50);
  AF(1000,127);
  AT(90,50);
  AF(1000,127);
  AT(90,50);
  AF(1000,127);
  AT(90,50);
}
void setZero(){
  AT(0,50);
}
task usercontrol()
{
	while (true){
  string Direction="";//beginning of orthoganal/ordinal direction script-N S E W NE SE NW SW
  int JS1=vexRT[Ch1];
  int JS2=vexRT[Ch2];
  if (JS1>50){
    if (JS2>50){
      Direction="NE";
    }
    if (abs(JS2)<50){
      Direction="E";
    }
    if (JS2<-50){
      Direction="SE";
    }
}
  if (JS1<-50){
    if (JS2>50){
      Direction="NW";
    }
    if (abs(JS2)<50){
      Direction="W";
    }
    if (JS2<-50){
      Direction="SW";
    }
}
if (abs(JS1)<50){
  if (JS2>50){
    Direction="N";
  }
  if (JS2<-50){
    Direction="S";
  }
}
	  int r=0;
	  if (abs(vexRT[Ch4])>50){//used to tell when the turning joystick is being used, see "void forward"
	    r=1;
	  }

	  if(Direction=="N"){
	    forward(vexRT[Ch2],r);//interprets the orthal-ordinal directions on the right joystick
	  }
	  if(Direction=="S"){
	    forward(vexRT[Ch2],r);
	  }
	  if (Direction=="W"){
	    right(vexRT[Ch1],r);
	  }
	  if (Direction=="E"){
	    right(vexRT[Ch1],r);
	  }
	  if(Direction=="NW"){
	    diagonal(127,1);//1=Left, 2=Right
	  }
	  if(Direction=="SW"){
	    diagonal(-127,2);
	  }
	  if (Direction=="NE"){
      diagonal(127,2);
	  }
	  if (Direction=="SE"){
	    diagonal(-127,1);
	  }



	  if (vexRT[Btn8U]==1){//right keypad
	    forward(127,r);
	  }
	  if (vexRT[Btn8D]==1){
	    forward(-127,r);
	  }
	  if (vexRT[Btn8R]==1){
	    right(127,r);
	  }
	  if (vexRT[Btn8L]==1){
	    right(-127,r);
	  }

	  if (vexRT[Btn6U]==1){
	    SensorValue[Gyro]=0;//resets the gyroscope
	  }
	  if (vexRT[Btn5U]==1){
	    forwardZero();//go forward using the gyroscope, r=2
	  }


	  if (vexRT[Btn7R]==1){//left keypad, mostly for testing
	    diagonal(127*directionMode,2);
	  }
	  if (vexRT[Btn7L]==1){
	    diagonal(127*directionMode,1);
	  }
	  if (vexRT[Btn7U]==1){
	    directionMode=1;
	  }
	  if (vexRT[Btn7D]==1){
	    directionMode=-1;
	  }
    bool stopStop=false;//variable that stops the expression of the stopC command so it doesn't jitter
    if (vexRT[Btn5U]==1){
      stopStop=true;
    }
    else{
      stopStop=false;
    }
    if (abs(vexRT[Ch4])>50){//left joystick
      if (abs(vexRT[Ch1])<50){
        if (abs(vexRT[Ch2])<50){
         turn(vexRT[Ch4]);
       }
       }
    }

    else{
      if (stopStop!=true){
        stopC();
      }
    }
	}
}
