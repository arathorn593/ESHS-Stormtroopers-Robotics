#pragma config(Sensor, dgtl1,  touchTop,       sensorTouch)
#pragma config(Sensor, dgtl2,  touchBottom,    sensorTouch)
#pragma config(Sensor, dgtl3,  encoderArmLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderArmRight, sensorQuadEncoder)
#pragma config(Motor,  port1,           intakeLeft,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           driveRightBack, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           LiftLeftTop,   tmotorVex393, openLoop)
#pragma config(Motor,  port4,           driveRightFront, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           driveLeftFront, tmotorVex393, openLoop)
#pragma config(Motor,  port6,           LiftLeftBottom, tmotorVex393, openLoop)
#pragma config(Motor,  port7,           LiftRightBottom, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           driveLeftBack, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           LiftRightTop,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          intakeRight,   tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int baseNewVal = 0;
int baseOldVal=0;
int midNewVal=0;
int midOldVal=0;
int topNewVal=0;
int topOldVal=0;
int state = 0;
int goalSpeedRight = 0;
int goalSpeedLeft = 0;
bool incrementRight = 0;
bool incrementLeft = 0;
int currentSpeedRight = 0;
int currentSpeedLeft = 0;
int incrementTimeRight = 0;
int incrementTimeLeft = 0;

void setDriveRight(int speed)
{
	motor[driveRightBack] = speed;
	motor[driveRightFront] = speed;
}

void setDriveLeft(int speed)
{
	motor[driveLeftBack] = speed;
	motor[driveLeftFront] = speed;
}

/*control for the right side drive of the robot
highGear = speed when joystick is full
low gear = speed when joystick is in the middle
bottomThresh = below this now power will go to the motors
topThresh= below this the motors will be at the low gear speed */
void driveRight(int highGear, int lowGear, int bottomThresh, int topThresh)
{
	if(abs(vexRT[Ch2]) > bottomThresh)			//if the joystick input is above the bottom threshold then assign motors speeds
	{
	  if(abs(vexRT[Ch2]) < topThresh)			//if the joystick input is below the top thresh hold then go to low gear
	  {
	    motor[driveRightBack] = lowGear;
	    motor[driveRightFront] = lowGear;
	  }
	  else																		//otherwise go to high gear
	  {
	    motor[driveRightBack] = highGear;
	    motor[driveRightFront] = highGear;
	  }
	}
	else																		//stop motors if nothing joystick isn't giving appropriate
	{
	  motor[driveRightBack] = 0;
	  motor[driveRightFront] = 0;
	}
}

/*control for the let side drive of the robot
highGear = speed when joystick is full
low gear = speed when joystick is in the middle
bottomThresh = below this now power will go to the motors
topThresh= below this the motors will be at the low gear speed */
void driveLeft(int highGear, int lowGear, int bottomThresh, int topThresh)
{
	if(abs(vexRT[Ch3]) > bottomThresh)			//if the joystick input is above the bottom threshold then assign motors speeds
	{
	  if(abs(vexRT[Ch3]) < topThresh)			//if the joystick input is below the top thresh hold then go to low gear
	  {
	   	motor[driveLeftBack] = lowGear;
	    motor[driveLeftFront] = lowGear;
	  }
	  else																		//otherwise go to high gear
	  {
	    motor[driveLeftBack] = highGear;
	    motor[driveLeftFront] = highGear;
	  }
	}
	else																		//stop motors if nothing joystick isn't giving appropriate
	{
	 	motor[driveLeftBack] = 0;
	  motor[driveLeftFront] = 0;
	}
}

void incrementDriveRight(int highGear, int lowGear, int bottomThresh, int topThresh, int incrementTime, int increment)
{
	if(abs(vexRT[Ch2]) > bottomThresh)
	{
	  if(abs(vexRT[Ch2]) < topThresh)
	  {
	  	goalSpeedRight = vexRT[Ch2]/lowGear;
	  }
	  else
	  {
	  	goalSpeedRight = highGear;
	  }
	}
	else
	{
		goalSpeedRight = 0;
	}

	if(goalSpeedRight != currentSpeedRight)
	{
		incrementRight = true;
	}
	else
	{
		incrementRight = false;
		incrementTimeRight = -1;
		time1[T1] = 0;
	}

	if(incrementRight)
	{
		if(time1[T1] > 30000)
		{
			ClearTimer(T1);
			incrementTimeRight -= 30000;

			if(incrementTimeRight < 0)
			{
				incrementTimeRight = time1[T1] + increment;
			}
			if(time1[T1] >= incrementTimeRight)
			{
				currentSpeedRight += 1;
				incrementTimeRight += increment;
			}
		}
	}
	setDriveRight(currentSpeedRight);
}

void incrementDriveLeft(int highGear, int lowGear, int bottomThresh, int topThresh, int incrementTime, int increment)
{
	if(abs(vexRT[Ch3]) > bottomThresh)
	{
	  if(abs(vexRT[Ch3]) < topThresh)
	  {
	  	goalSpeedLeft = vexRT[Ch3]/lowGear;
	  }
	  else
	  {
	  	goalSpeedLeft = highGear;
	  }
	}
	else
	{
		goalSpeedLeft = 0;
	}

	if(goalSpeedLeft != currentSpeedLeft)
	{
		incrementLeft = true;
	}
	else
	{
		incrementLeft = false;
		incrementTimeLeft = -1;
		time1[T1] = 0;
	}

	if(incrementLeft)
	{
		if(time1[T2] > 30000)
		{
			ClearTimer(T2);
			incrementTimeLeft -= 30000;

			if(incrementTimeLeft < 0)
			{
				incrementTimeLeft = time1[T2] + increment;
			}
			if(time1[T2] >= incrementTimeLeft)
			{
				currentSpeedLeft += 1;
				incrementTimeLeft += increment;
			}
		}
	}
	setDriveLeft(currentSpeedLeft);
}



/*control program for the lift
trough = the encoder height for the trough
highGoal = the encoder height for the high goal*/
void eightBar(int trough, int highGoal)
{
	//these put the value of the top and bottom buttons in the apropriate variable
	baseNewVal = vexRT[Btn8D];
	topNewVal = vexRT[btn8U];
	//this allows either of the middle buttons to trigger the middle varible
	if((vexRT[Btn8L] == 1) || (vexRT[Btn8L] == 1))
	{
		midNewVal = 1;
	}
	else
	{
		midNewVal = 0;
	}

	//These 3 if statements say that for each of the hieghts
	//if the new value is 1(pressed) and the old value is 0(unpressed)
	//then it was a legitamate button press and sets the state to the
	//correct level.
	if((baseNewVal == 1) && (baseOldVal == 0))
	{
		state = 1;
	}

	if((midNewVal == 1) && (midOldVal == 0))
	{
		state = 2;
	}

	if((topNewVal == 1) && (topOldVal == 0))
	{
		state = 3;
	}

	topOldVal = topNewVal;
	midOldVal = midNewVal;
	baseOldVal = baseNewVal;

	if(vexRT[Btn6D] == 1)
	{
		if(SensorValue[touchBottom] == 0)
		{
			motor[LiftLeftBottom] = -127;
			motor[LiftLeftTop] = -127;
			motor[LiftRightBottom] = -127;
			motor[LiftRightTop] = -127;
		}
		else
		{
			motor[LiftLeftBottom] = 0;
			motor[LiftLeftTop] = 0;
			motor[LiftRightBottom] = 0;
			motor[LiftRightTop] = 0;
		}
	}
	else if(vexRT[Btn6U] == 1)
	{
		if(SensorValue[touchTop] == 0)
		{
			motor[LiftLeftBottom] = 127;
			motor[LiftLeftTop] = 127;
			motor[LiftRightBottom] = 127;
			motor[LiftRightTop] = 127;
		}
		else
		{
			motor[LiftLeftBottom] = 0;
			motor[LiftLeftTop] = 0;
			motor[LiftRightBottom] = 0;
			motor[LiftRightTop] = 0;
		}
	}
	else
	{
		if(state == 1)
		{
			if(SensorValue[touchBottom] == 0)
			{
				motor[LiftLeftBottom] = -127;
				motor[LiftLeftTop] = -127;
				motor[LiftRightBottom] = -127;
				motor[LiftRightTop] = -127;
			}
			else
			{
				motor[LiftLeftBottom] = 0;
				motor[LiftLeftTop] = 0;
				motor[LiftRightBottom] = 0;
				motor[LiftRightTop] = 0;
				state = 0;
			}
		}
		else if(state == 2)
		{
			if(SensorValue[encoderArmLeft] > trough)
			{
				motor[LiftLeftBottom] = -127;
				motor[LiftLeftTop] = -127;
			}
			else if(SensorValue[encoderArmLeft] < trough)
			{
				motor[LiftLeftBottom] = 127;
				motor[LiftLeftTop] = 127;
			}
			else
			{
				motor[LiftLeftBottom] = 0;
				motor[LiftLeftTop] = 0;
				state = 0;
			}

			if(SensorValue[encoderArmRight] > trough)
			{
				motor[LiftRightBottom] = -127;
				motor[LiftRightTop] = -127;
			}
			else if(SensorValue[encoderArmRight] < trough)
			{
				motor[LiftRightBottom] = 127;
				motor[LiftRightTop] = 127;
			}
			else
			{
				motor[LiftRightBottom] = 0;
				motor[LiftRightTop] = 0;
				state = 0;
			}
		}
		else if(state == 3)
		{
			if(SensorValue[encoderArmLeft] > trough)
			{
				motor[LiftLeftBottom] = -127;
				motor[LiftLeftTop] = -127;
			}
			else if(SensorValue[encoderArmLeft] < trough)
			{
				motor[LiftLeftBottom] = 127;
				motor[LiftLeftTop] = 127;
			}
			else
			{
				motor[LiftLeftBottom] = 0;
				motor[LiftLeftTop] = 0;
				state = 0;
			}

			if(SensorValue[encoderArmRight] > highGoal)
			{
				motor[LiftRightBottom] = -127;
				motor[LiftRightTop] = -127;
			}
			else if(SensorValue[encoderArmRight] < highGoal)
			{
				motor[LiftRightBottom] = 127;
				motor[LiftRightTop] = 127;
			}
			else
			{
				motor[LiftRightBottom] = 0;
				motor[LiftRightTop] = 0;
				state = 0;
			}
		}
		else
		{
			motor[LiftLeftBottom] = 0;
			motor[LiftLeftTop] = 0;
			motor[LiftRightBottom] = 0;
			motor[LiftRightTop] = 0;
		}
	}
}

void intake(int inSpeed, int outSpeed)
{
	if(vexRT[Btn5D] == 1)
	{
		motor[intakeLeft] = inSpeed;
		motor[intakeRight] = inSpeed;
	}
	else if(vexRT[Btn6U] == 1)
	{
		motor[intakeLeft] = -outSpeed;
		motor[intakeRight] = -outSpeed;
	}
	else
	{
		motor[intakeLeft] = 0;
		motor[intakeRight] = 0;
	}
}

task main()
{

}
