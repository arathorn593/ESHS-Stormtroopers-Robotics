#pragma config(Sensor, dgtl1,  touchTop,       sensorTouch)
#pragma config(Sensor, dgtl2,  touchBottom,    sensorTouch)
#pragma config(Sensor, dgtl3,  encoderArmLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderArmRight, sensorQuadEncoder)
#pragma config(Motor,  port1,           intakeLeft,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           driveRightBack, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           LiftLeftTop,   tmotorVex393, openLoop)
#pragma config(Motor,  port4,           driveRightFront, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           driveLeftFront, tmotorVex393, openLoop)
#pragma config(Motor,  port6,           LiftLeftBottom, tmotorVex393, openLoop)
#pragma config(Motor,  port7,           LiftRightBottom, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           driveLeftBack, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           LiftRightTop,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          intakeRight,   tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


int baseNewVal = 0;
int baseOldVal=0;
int midNewVal=0;
int midOldVal=0;
int topNewVal=0;
int topOldVal=0;
int state = 0;
int goalSpeedRight = 0;
int goalSpeedLeft = 0;
bool incrementRight = 0;
bool incrementLeft = 0;
int currentSpeedRight = 0;
int currentSpeedLeft = 0;
int incrementTimeRight = 0;
int incrementTimeLeft = 0;

void setDriveRight(int speed)
{
	motor[driveRightBack] = speed;
	motor[driveRightFront] = speed;
}

void setDriveLeft(int speed)
{
	motor[driveLeftBack] = speed;
	motor[driveLeftFront] = speed;
}

/*control for the right side drive of the robot
highGear = speed when joystick is full
low gear = speed when joystick is in the middle
bottomThresh = below this now power will go to the motors
topThresh= below this the motors will be at the low gear speed */
void driveRight(int highGear, int lowGear, int bottomThresh, int topThresh)
{
	if(abs(vexRT[Ch2]) > bottomThresh)			//if the joystick input is above the bottom threshold then assign motors speeds
	{
	  if(abs(vexRT[Ch2]) < topThresh)			//if the joystick input is below the top thresh hold then go to low gear
	  {
	    motor[driveRightBack] = lowGear;
	    motor[driveRightFront] = lowGear;
	  }
	  else																		//otherwise go to high gear
	  {
	    motor[driveRightBack] = highGear;
	    motor[driveRightFront] = highGear;
	  }
	}
	else																		//stop motors if nothing joystick isn't giving appropriate
	{
	  motor[driveRightBack] = 0;
	  motor[driveRightFront] = 0;
	}
}

/*control for the let side drive of the robot
highGear = speed when joystick is full
low gear = speed when joystick is in the middle
bottomThresh = below this now power will go to the motors
topThresh= below this the motors will be at the low gear speed */
void driveLeft(int highGear, int lowGear, int bottomThresh, int topThresh)
{
	if(abs(vexRT[Ch3]) > bottomThresh)			//if the joystick input is above the bottom threshold then assign motors speeds
	{
	  if(abs(vexRT[Ch3]) < topThresh)			//if the joystick input is below the top thresh hold then go to low gear
	  {
	   	motor[driveLeftBack] = lowGear;
	    motor[driveLeftFront] = lowGear;
	  }
	  else																		//otherwise go to high gear
	  {
	    motor[driveLeftBack] = highGear;
	    motor[driveLeftFront] = highGear;
	  }
	}
	else																		//stop motors if nothing joystick isn't giving appropriate
	{
	 	motor[driveLeftBack] = 0;
	  motor[driveLeftFront] = 0;
	}
}

int incrementDriveRight(int lowGear, int bottomThresh, int topThresh, int incrementTime, int increment)
{
	if(abs(vexRT[Ch2]) > bottomThresh)
	{
	  if(abs(vexRT[Ch2]) < topThresh)
	  {
	  	goalSpeedRight = vexRT[Ch2]/lowGear;
	  }
	  else
	  {
	  	goalSpeedRight = vexRT[Ch2];
	  }
	}
	else
	{
		goalSpeedRight = 0;
	}

	if(goalSpeedRight != currentSpeedRight)
	{
		incrementRight = true;
	}
	else
	{
		incrementRight = false;
		incrementTimeRight = -1;
		time1[T1] = 0;
	}

	if(incrementRight)
	{
		if(time1[T1] > 30000)
		{
			ClearTimer(T1);
			incrementTimeRight -= 30000;
		}
		if(incrementTimeRight < 0)
			{
				incrementTimeRight = time1[T1] + incrementTime;
			}
			if(time1[T1] >= incrementTimeRight)
			{
			  incrementTimeRight += incrementTime;
			  if(goalSpeedRight > currentSpeedRight)
			  {
				  currentSpeedRight += increment;
				}
				else
				{
				  currentSpeedRight -= increment;

				}

			}
	}
  return currentSpeedRight;
}

int incrementDriveLeft(int lowGear, int bottomThresh, int topThresh, int incrementTime, int increment)
{
	if(abs(vexRT[Ch3]) > bottomThresh)
	{
	  if(abs(vexRT[Ch3]) < topThresh)
	  {
	  	goalSpeedLeft = vexRT[Ch3]/lowGear;
	  }
	  else
	  {
	  	goalSpeedLeft = vexRT[Ch3];
	  }
	}
	else
	{
		goalSpeedLeft = 0;
	}

	if(goalSpeedLeft != currentSpeedLeft)
	{
		incrementLeft = true;
	}
	else
	{
		incrementLeft = false;
		incrementTimeLeft = -1;
		time1[T2] = 0;
	}

	if(incrementLeft)
	{
		if(time1[T2] > 30000)
		{
			ClearTimer(T2);
			incrementTimeLeft -= 30000;
		}
		if(incrementTimeLeft < 0)
			{
				incrementTimeLeft = time1[T2] + incrementTime;
			}
			if(time1[T1] >= incrementTimeLeft)
			{
			  incrementTimeLeft += incrementTime;
			  if(goalSpeedLeft > currentSpeedLeft)
			  {
				  currentSpeedLeft += increment;
				}
				else
				{
				  currentSpeedLeft -= increment;
				}

			}
	}
	return currentSpeedLeft;
}



/*control program for the lift
trough = the encoder height for the trough
highGoal = the encoder height for the high goal
void eightBar(int trough, int highGoal)
{
	//these put the value of the top and bottom buttons in the apropriate variable
	baseNewVal = vexRT[Btn8D];
	topNewVal = vexRT[btn8U];
	//this allows either of the middle buttons to trigger the middle varible
	if((vexRT[Btn8L] == 1) || (vexRT[Btn8L] == 1))
	{
		midNewVal = 1;
	}
	else
	{
		midNewVal = 0;
	}

	//These 3 if statements say that for each of the hieghts
	//if the new value is 1(pressed) and the old value is 0(unpressed)
	//then it was a legitamate button press and sets the state to the
	//correct level.
	if((baseNewVal == 1) && (baseOldVal == 0))
	{
		state = 1;
	}

	if((midNewVal == 1) && (midOldVal == 0))
	{
		state = 2;
	}

	if((topNewVal == 1) && (topOldVal == 0))
	{
		state = 3;
	}

	topOldVal = topNewVal;
	midOldVal = midNewVal;
	baseOldVal = baseNewVal;

	if(vexRT[Btn6D] == 1)
	{
		if(SensorValue[touchBottom] == 0)
		{
			motor[LiftLeftBottom] = -127;
			motor[LiftLeftTop] = -127;
			motor[LiftRightBottom] = -127;
			motor[LiftRightTop] = -127;
		}
		else
		{
			motor[LiftLeftBottom] = 0;
			motor[LiftLeftTop] = 0;
			motor[LiftRightBottom] = 0;
			motor[LiftRightTop] = 0;
		}
	}
	else if(vexRT[Btn6U] == 1)
	{
		if(SensorValue[touchTop] == 0)
		{
			motor[LiftLeftBottom] = 127;
			motor[LiftLeftTop] = 127;
			motor[LiftRightBottom] = 127;
			motor[LiftRightTop] = 127;
		}
		else
		{
			motor[LiftLeftBottom] = 0;
			motor[LiftLeftTop] = 0;
			motor[LiftRightBottom] = 0;
			motor[LiftRightTop] = 0;
		}
	}
	else
	{
		if(state == 1)
		{
			if(SensorValue[touchBottom] == 0)
			{
				motor[LiftLeftBottom] = -127;
				motor[LiftLeftTop] = -127;
				motor[LiftRightBottom] = -127;
				motor[LiftRightTop] = -127;
			}
			else
			{
				motor[LiftLeftBottom] = 0;
				motor[LiftLeftTop] = 0;
				motor[LiftRightBottom] = 0;
				motor[LiftRightTop] = 0;
				state = 0;
			}
		}
		else if(state == 2)
		{
			if(SensorValue[encoderArmLeft] > trough)
			{
				motor[LiftLeftBottom] = -127;
				motor[LiftLeftTop] = -127;
			}
			else if(SensorValue[encoderArmLeft] < trough)
			{
				motor[LiftLeftBottom] = 127;
				motor[LiftLeftTop] = 127;
			}
			else
			{
				motor[LiftLeftBottom] = 0;
				motor[LiftLeftTop] = 0;
				state = 0;
			}

			if(SensorValue[encoderArmRight] > trough)
			{
				motor[LiftRightBottom] = -127;
				motor[LiftRightTop] = -127;
			}
			else if(SensorValue[encoderArmRight] < trough)
			{
				motor[LiftRightBottom] = 127;
				motor[LiftRightTop] = 127;
			}
			else
			{
				motor[LiftRightBottom] = 0;
				motor[LiftRightTop] = 0;
				state = 0;
			}
		}
		else if(state == 3)
		{
			if(SensorValue[encoderArmLeft] > trough)
			{
				motor[LiftLeftBottom] = -127;
				motor[LiftLeftTop] = -127;
			}
			else if(SensorValue[encoderArmLeft] < trough)
			{
				motor[LiftLeftBottom] = 127;
				motor[LiftLeftTop] = 127;
			}
			else
			{
				motor[LiftLeftBottom] = 0;
				motor[LiftLeftTop] = 0;
				state = 0;
			}

			if(SensorValue[encoderArmRight] > highGoal)
			{
				motor[LiftRightBottom] = -127;
				motor[LiftRightTop] = -127;
			}
			else if(SensorValue[encoderArmRight] < highGoal)
			{
				motor[LiftRightBottom] = 127;
				motor[LiftRightTop] = 127;
			}
			else
			{
				motor[LiftRightBottom] = 0;
				motor[LiftRightTop] = 0;
				state = 0;
			}
		}
		else
		{
			motor[LiftLeftBottom] = 0;
			motor[LiftLeftTop] = 0;
			motor[LiftRightBottom] = 0;
			motor[LiftRightTop] = 0;
		}
	}
}*/

void intake(int inSpeed, int outSpeed)
{
	if(vexRT[Btn5D] == 1)
	{
		motor[intakeLeft] = inSpeed;
		motor[intakeRight] = inSpeed;
	}
	else if(vexRT[Btn6U] == 1)
	{
		motor[intakeLeft] = -outSpeed;
		motor[intakeRight] = -outSpeed;
	}
	else
	{
		motor[intakeLeft] = 0;
		motor[intakeRight] = 0;
	}
}

task usercontrol()
{
	int realLowGear = 2;					//what the channel output will be divided by in the low gear
	int realBottomThresh = 50;			//what the cutoff is for no movement
	int realTopThresh = 120;				//what the cutoff is for the low gear
	int realIncrementTime = 2;		//how many milliseconds bettween each increment
	int realIncrement = 1;				//amount of each increment

	while (true)
	{
	  motor[driveLeftBack] = incrementDriveLeft(realLowGear, realBottomThresh, realTopThresh, realIncrementTime, realIncrement);
	  motor[driveLeftFront] = incrementDriveLeft(realLowGear, realBottomThresh, realTopThresh, realIncrementTime, realIncrement);
    motor[driveRightBack] = 	  incrementDriveRight(realLowGear, realBottomThresh, realTopThresh, realIncrementTime, realIncrement);
    motor[driveRightFront] = 	  incrementDriveRight(realLowGear, realBottomThresh, realTopThresh, realIncrementTime, realIncrement);
	}
}
