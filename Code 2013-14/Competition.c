#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    accelX,         sensorAnalog)
#pragma config(Sensor, in3,    accelY,         sensorAnalog)
#pragma config(Sensor, in4,    accelZ,         sensorAnalog)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, in6,    pwrExp,         sensorAnalog)
#pragma config(Sensor, in7,    autoPosition,   sensorPotentiometer)
#pragma config(Sensor, in8,    autoPlan,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  touchBottom,    sensorTouch)
#pragma config(Sensor, dgtl6,  touchTop,       sensorTouch)
#pragma config(Sensor, dgtl7,  jumperSkills,   sensorTouch)
#pragma config(Sensor, dgtl11, pPunchL,        sensorDigitalOut)
#pragma config(Sensor, dgtl12, pPunchR,        sensorDigitalOut)
#pragma config(Motor,  port1,           intakeL,       tmotorVex393, openLoop)
#pragma config(Motor,  port2,           RD,            tmotorVex393, PIDControl, encoder, encoderPort, dgtl1, 1000)
#pragma config(Motor,  port3,           armRU,         tmotorVex393, openLoop)
#pragma config(Motor,  port4,           armRD,         tmotorVex393, openLoop)
#pragma config(Motor,  port5,           RU,            tmotorVex393, PIDControl, encoder, encoderPort, dgtl1, 1000)
#pragma config(Motor,  port6,           LU,            tmotorVex393, PIDControl, reversed, encoder, encoderPort, dgtl3, 1000)
#pragma config(Motor,  port7,           armLD,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           armLU,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           LD,            tmotorVex393, PIDControl, reversed, encoder, encoderPort, dgtl3, 1000)
#pragma config(Motor,  port10,          intakeR,       tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//#include "Functions/ChassisFunctions.c"
//#include "Functions/ArmFunctions.c"
#include "Functions/compAuto.c"
#include "DriverTryout.c"

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int auto = 0; //1 = A1, 2 = A2, 3 = B1

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
  /*displayLCDCenteredString(0, "Choose Auto");
  while(nLCDButtons == 0){
  }
  if(nLCDButtons == 1){
  	auto = 1;
  }else if(nLCDButtons == 2){
  	auto = 2;
  }else if(nLCDButtons == 4){
  	auto = 3;
  }*/
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

//these define the boundaries of the potentiometer selection
//tile: RH(00__)/RS(01__)/BS(10__)/BH(11__)
//auton: A(__00)/B(__01)/C(__10)/D(__11)
const int autoRH = 0;
const int autoRS = 4;
const int autoBS = 8;
const int autoBH = 12;

const int autoA = 0;
const int autoB = 1;
const int autoC = 2;
const int autoD = 3;

const int RH_RS = ceil(4095 * 0.25);
const int RS_BS = ceil(4095 * 0.5);
const int BS_BH = ceil(4095 * 0.75);

const int C_D = ceil(4095 * 0.25);
const int B_C = ceil(4095 * 0.5);
const int A_B = ceil(4095 * 0.75);

task autonomous()
{
	clearLCDLine(0);
	clearLCDLine(1);

	if(SensorValue[jumperSkills] != 1){
		int posPot = SensorValue[autoPosition];
		int planPot = SensorValue[autoPlan];
		int planNum = 0;

		if(posPot < RH_RS){
			planNum += autoRH;
		}else if(posPot < RS_BS){
			planNum += autoRS;
		}else if(posPot < BS_BH){
			planNum += autoBS;
		}else{
			planNum += autoBH;
		}

		if(planPot > A_B){
			planNum += autoA;
		}else if(planPot > B_C){
			planNum += autoB;
		}else if(planPot > C_D){
			planNum += autoC;
		}else{
			planNum += autoD;
		}

		switch(planNum)
		{
			case 0:
				displayLCDCenteredString(0, "A1 red");
				A1(1);
				break;

			case 1:
				displayLCDCenteredString(0, "Skills");
				skillsAutonomous();
				break;

			case 2: case 3:
				displayLCDCenteredString(0, "A3 red");
				A3(1);
				break;

			case 4: case 5:
				displayLCDCenteredString(0, "B1 red");
				B1(1);
				break;

			case 6: case 7:
				displayLCDCenteredString(0, "B1 red");
				B1(1);
				break;

			case 8: case 9:
				displayLCDCenteredString(0, "B1 blue");
				B1(-1);
				break;

			case 10: case 11:
				displayLCDCenteredString(0, "B1 blue");
				B1(-1);
				break;

			case 12: case 13:
			 	displayLCDCenteredString(0, "A1 blue");
				A1(-1);
				break;

			case 14: case 15:
				displayLCDCenteredString(0, "A3 blue");
				A3(-1);
				break;

			default:
		}
	}else{
		skillsAutonomous();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	clearLCDLine(0);
	clearLCDLine(1);

	while(true){
		driverJoseph();

		if(nLCDButtons == 1){
			batLCD();
		}else{
			chasLCD();
		}
	}
}
